import openai
import os
from dotenv import find_dotenv, load_dotenv
import time
import logging
from datetime import datetime
import requests
import json
import streamlit as st

load_dotenv()
# openai.api_key = os.environ.get("OPENAI_API_KEY")
# defaults to getting the key using os.environ.get("OPENAI_API_KEY")
# if you saved the key under a different environment variable name, you can do something like:
# client = OpenAI(
#   api_key=os.environ.get("CUSTOM_ENV_NAME"),
# )

news_api_key = os.environ.get("NEWS_API_KEY")

client = openai.OpenAI()
model = "gpt-3.5-turbo-16k"


def get_news(topic):
    """
    Fetches the latest news articles related to a specific topic using the NewsAPI.

    This function constructs a request to the NewsAPI with the given topic and the API key obtained from the environment variables. It then sends the request and processes the response, extracting the relevant information from each article in the response. The information extracted includes the article's title, author, source, description, and URL. Each article's information is formatted into a string and added to a list, which is then returned.

    Parameters:
    - topic (str): The topic for which news articles are to be fetched.

    Returns:
    - list: A list of strings, each representing the information of an article related to the given topic. If the request is unsuccessful or no articles are found, an empty list is returned.

    Exceptions:
    - Prints an error message if a request exception occurs during the API call.
    """
    url = (
        f"https://newsapi.org/v2/everything?q={topic}&apiKey={news_api_key}&pageSize=5"
    )

    try:
        response = requests.get(url)
        if response.status_code == 200:
            news = json.dumps(response.json(), indent=4)
            news_json = json.loads(news)

            data = news_json

            # Access all the fields == loop through
            status = data["status"]
            total_results = data["totalResults"]
            articles = data["articles"]
            final_news = []

            # Loop through articles
            for article in articles:
                source_name = article["source"]["name"]
                author = article["author"]
                title = article["title"]
                description = article["description"]
                url = article["url"]
                content = article["content"]
                title_description = f"""
                   Title: {title}, 
                   Author: {author},
                   Source: {source_name},
                   Description: {description},
                   URL: {url}
            
                """
                final_news.append(title_description)

            return final_news
        else:
            return []

    except requests.exceptions.RequestException as e:
        print("Error occured during API Request", e)


class AssistantManager:
    thread_id = "thread_FiBZi6Iu1vikvYC8k4Reo1gU"
    assistant_id = "asst_0PTiHZ7CQI1OHispos5FzZ9D"

    def __init__(self, model: str = model):
        """
        Initializes an instance of the AssistantManager class.

        This constructor initializes the AssistantManager with a specified model and sets up the initial state for the assistant and thread management. It attempts to retrieve existing assistant and thread objects using their IDs if they are already set. If the IDs are not set, the assistant and thread attributes are initialized as None.

        Parameters:
        - model (str): The model identifier to be used with the OpenAI API. Defaults to the global `model` variable.

        Attributes:
        - client (OpenAI): An instance of the OpenAI client initialized with the API key.
        - model (str): The model identifier to be used for the assistant.
        - assistant (OpenAI Assistant or None): The assistant object retrieved from OpenAI, or None if not yet created or retrieved.
        - thread (OpenAI Thread or None): The thread object retrieved from OpenAI, or None if not yet created or retrieved.
        - run (None): Placeholder for future run objects created during the assistant's operation.
        - summary (None): Placeholder for storing summaries generated by the assistant.
        """
        self.client = client
        self.model = model
        self.assistant = None
        self.thread = None
        self.run = None
        self.summary = None

        # Retrieve existing assistant and thread if IDs are already set
        if AssistantManager.assistant_id:
            self.assistant = self.client.beta.assistants.retrieve(
                assistant_id=AssistantManager.assistant_id
            )
        if AssistantManager.thread_id:
            self.thread = self.client.beta.threads.retrieve(
                thread_id=AssistantManager.thread_id
            )

    def create_assistant(self, name, instructions, tools):
        """
        Creates a new assistant in the OpenAI platform if one does not already exist for this instance.

        This method checks if an assistant has already been created for this instance of the AssistantManager class. If not, it proceeds to create a new assistant on the OpenAI platform using the provided name, instructions, and tools. The newly created assistant's ID is then stored in the class variable `assistant_id`, and the assistant object is stored in the instance variable `assistant`. A message displaying the new assistant's ID is printed to the console.

        Parameters:
        - name (str): The name of the assistant to be created.
        - instructions (str): Instructions for the assistant, describing its purpose or task.
        - tools (list): A list of tools that the assistant can use to perform its tasks.

        Returns:
        - None
        """
        if not self.assistant:
            assistant_obj = self.client.beta.assistants.create(
                name=name, instructions=instructions, tools=tools, model=self.model
            )
            AssistantManager.assistant_id = assistant_obj.id
            self.assistant = assistant_obj
            print(f"AssisID:::: {self.assistant.id}")

    def create_thread(self):
        """
        Creates a new thread in the OpenAI platform if one does not already exist for this instance.

        This method checks if a thread has already been created for this instance of the AssistantManager class. If not, it proceeds to create a new thread on the OpenAI platform. The newly created thread's ID is then stored in the class variable `thread_id`, and the thread object is stored in the instance variable `thread`. A message displaying the new thread's ID is printed to the console.

        Parameters:
        - None

        Returns:
        - None
        """
        if not self.thread:
            thread_obj = self.client.beta.threads.create()
            AssistantManager.thread_id = thread_obj.id
            self.thread = thread_obj
            print(f"ThreadID::: {self.thread.id}")

    def add_message_to_thread(self, role, content):
        """
        Adds a message to an existing thread in the OpenAI platform.

        This method checks if a thread object exists for the current instance of the AssistantManager class. If a thread exists, it creates a new message in this thread using the OpenAI API. The message is defined by its role (e.g., "user" or "system") and its content.

        Parameters:
        - role (str): The role of the message, indicating who is the sender of the message. Common roles include "user" for messages sent by the user and "system" for messages sent by the system or assistant.
        - content (str): The actual content of the message to be added to the thread.

        Returns:
        - None
        """
        if self.thread:
            self.client.beta.threads.messages.create(
                thread_id=self.thread.id, role=role, content=content
            )

    def run_assistant(self, instructions):
        """
        Initiates the assistant to process a set of instructions within a specific thread.

        This method checks if both the thread and assistant objects exist for the current instance. If they do, it creates a new run within the specified thread using the assistant. The run is tasked with processing the given instructions. The method stores the created run object in the instance variable `self.run` for future reference.

        Parameters:
        - instructions (str): The instructions or query that the assistant needs to process.

        Returns:
        - None
        """
        if self.thread and self.assistant:
            self.run = self.client.beta.threads.runs.create(
                thread_id=self.thread.id,
                assistant_id=self.assistant.id,
                instructions=instructions,
            )

    def process_message(self):
        """
        Processes the last message in the thread and updates the summary attribute.

        This method retrieves the list of messages from the current thread using the OpenAI API. It then extracts the last message from this list, assuming it to be the most recent response from the assistant. The role and content of this message are extracted, and the content is appended to the summary list. The summary attribute of the instance is then updated to a string containing all items in the summary list, joined by newline characters. Additionally, a log message is printed to the console displaying the role and content of the last message.

        Parameters:
        - None

        Returns:
        - None
        """
        if self.thread:
            messages = self.client.beta.threads.messages.list(thread_id=self.thread.id)
            summary = []

            last_message = messages.data[0]
            role = last_message.role
            response = last_message.content[0].text.value
            summary.append(response)

            self.summary = "\n".join(summary)
            print(f"SUMMARY-----> {role.capitalize()}: ==> {response}")

            # for msg in messages:
            #     role = msg.role
            #     content = msg.content[0].text.value
            #     print(f"SUMMARY-----> {role.capitalize()}: ==> {content}")

    def call_required_functions(self, required_actions):
        """
        Calls the required functions based on the actions specified by the OpenAI Assistant.

        This method iterates through a list of tool calls specified in the `required_actions` parameter. For each tool call, it identifies the function to be called by its name and passes the necessary arguments to it. If the function call is successful, the output is formatted and added to a list of tool outputs. These outputs are then submitted back to the Assistant via the OpenAI API.

        Parameters:
        - required_actions (dict): A dictionary containing the details of the tool calls required by the Assistant. This includes the function name and arguments for each tool call.

        Returns:
        - None: This method does not return a value but submits tool outputs back to the Assistant.

        Raises:
        - ValueError: If an unknown function name is encountered in the tool calls, a ValueError is raised.
        """
        if not self.run:
            return
        tool_outputs = []

        for action in required_actions["tool_calls"]:
            func_name = action["function"]["name"]
            arguments = json.loads(action["function"]["arguments"])

            if func_name == "get_news":
                output = get_news(topic=arguments["topic"])
                print(f"STUFFFFF;;;;{output}")
                final_str = ""
                for item in output:
                    final_str += "".join(item)

                tool_outputs.append({"tool_call_id": action["id"], "output": final_str})
            else:
                raise ValueError(f"Unknown function: {func_name}")

        print("Submitting outputs back to the Assistant...")
        self.client.beta.threads.runs.submit_tool_outputs(
            thread_id=self.thread.id, run_id=self.run.id, tool_outputs=tool_outputs
        )

    # for streamlit
    def get_summary(self):
        return self.summary

    def wait_for_completion(self):
        """
        Waits for the completion of the assistant's processing or for a required action to be performed.

        This method continuously checks the status of the current run within the thread. It polls the OpenAI API at regular intervals to retrieve the run's status. If the status is 'completed', it calls the `process_message` method to process the final message from the assistant. If the status is 'requires_action', it calls the `call_required_functions` method to perform any required actions specified by the assistant. The loop breaks once the run status is 'completed', indicating that the assistant has finished processing.

        Parameters:
        - None

        Returns:
        - None
        """
        if self.thread and self.run:
            while True:
                time.sleep(5)  # Wait for 5 seconds before checking the status again
                run_status = self.client.beta.threads.runs.retrieve(
                    thread_id=self.thread.id, run_id=self.run.id
                )
                print(f"RUN STATUS:: {run_status.model_dump_json(indent=4)}")

                if run_status.status == "completed":
                    self.process_message()  # Process the final message from the assistant
                    break  # Exit the loop as the assistant has completed processing
                elif run_status.status == "requires_action":
                    print("FUNCTION CALLING NOW...")
                    self.call_required_functions(
                        required_actions=run_status.required_action.submit_tool_outputs.model_dump()
                    )  # Perform any required actions specified by the assistant

    # Run the steps
    def run_steps(self):
        """
        Retrieves and lists all the steps of a run within a specific thread.

        This method calls the OpenAI API to list all the steps associated with a particular run in a thread. It prints the retrieved steps to the console for debugging or informational purposes. The steps provide insights into the sequence of actions or processes undertaken by the assistant during its operation.

        Returns:
        - list: A list of step objects associated with the run. Each step object contains detailed information about the actions performed by the assistant.
        """
        run_steps = self.client.beta.threads.runs.steps.list(
            thread_id=self.thread.id, run_id=self.run.id
        )
        print(f"Run-Steps::: {run_steps}")
        return run_steps.data


def main():
    """
    The main function that orchestrates the flow of the application.

    This function initializes the AssistantManager, sets up a Streamlit interface for user input, and handles the logic for creating an assistant, creating a thread, adding a message to the thread, running the assistant, waiting for the completion of the assistant's processing, and displaying the summary and run steps to the user.

    The Streamlit interface prompts the user to enter a topic for which they want news summaries. Upon submitting the topic, the function proceeds to create an assistant with specific instructions and tools, create a thread for communication, add the user's request as a message in the thread, and run the assistant to process the request. It waits for the assistant to complete processing, retrieves the summary of news articles, and displays it along with the steps taken by the assistant during processing.
    """
    manager = AssistantManager()

    # Streamlit interface setup
    st.title("News Summarizer")

    with st.form(key="user_input_form"):
        instructions = st.text_input("Enter topic:")
        submit_button = st.form_submit_button(label="Run Assistant")

        if submit_button:
            # Create an assistant with specific instructions and tools
            manager.create_assistant(
                name="News Summarizer",
                instructions="You are a personal article summarizer Assistant who knows how to take a list of article's titles and descriptions and then write a short summary of all the news articles",
                tools=[
                    {
                        "type": "function",
                        "function": {
                            "name": "get_news",
                            "description": "Get the list of articles/news for the given topic",
                            "parameters": {
                                "type": "object",
                                "properties": {
                                    "topic": {
                                        "type": "string",
                                        "description": "The topic for the news, e.g. bitcoin",
                                    }
                                },
                                "required": ["topic"],
                            },
                        },
                    }
                ],
            )
            # Create a thread for communication
            manager.create_thread()

            # Add the user's request as a message in the thread
            manager.add_message_to_thread(
                role="user", content=f"summarize the news on this topic {instructions}?"
            )
            # Run the assistant to process the request
            manager.run_assistant(instructions="Summarize the news.")

            # Wait for the assistant to complete processing
            manager.wait_for_completion()

            # Retrieve and display the summary of news articles
            summary = manager.get_summary()
            st.write(summary)

            # Display the steps taken by the assistant during processing
            st.text("Run Steps:")
            st.code(manager.run_steps(), line_numbers=True)


if __name__ == "__main__":
    main()
